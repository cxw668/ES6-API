## 1）通读 README + 配置文档，明确插件使用姿势与目标
- 产出：画出“ESLint -> plugin -> rules/configs”的调用链

这个仓库实现了一个ESLint插件，用于检查是否使用了lodash/underscore的方法。基于AST做静态扫描并报错/警告，同时提示使用原生方法的替代方案。
eslint 读取配置=> .eslintrc / eslint.config.* ; 根据plugins / extends 加载插件包 ; 插件对外暴露两类内容：rules(规则实现。每条规则是一个对象，包含create(context)) + configs(配置文件。包含rules的开启/关闭、插件的开启/关闭、继承其他配置等，把很多规则打包成all/compatible) ; eslint扫描源码文件生成AST ; 对每条规则执行 1）调用rule.create(context)拿到visitor 2）遍历AST，对每个节点调用rule.visitor的对应方法。
练习题：
  1. rules / configs
  - rules: 导出给eslint的规则实现集合，每个规则本质上是一个对象，核心是Create（context)返回visitor(访问器)
  - configs: 导出给eslint的预设配置文件集合，用于`extends:["plugin:xxx/compatibale"]`让用户一键启用一组规则并指定wanr/error级别。

  2. "extends": ["plugin:you-dont-need-lodash-underscore/compatible"] 中的compatible指什么？
  - compatible对应插件导出的module.exports.configs.compatible
  - compatible是插件在configs提供的一个配置名

  3. 为什么规则Key要写pluginName / ruleName
  - eslint需要这个插件名前缀来区分规则来源，避免多个规则同名

  4. 四个configs的区别
  - all: Object.keys(rules) 包含所有规则
  - compatible: 只取rules[rule].filter.compatible === true 的规则
  - incompatible: 取rules[rule].filter.compatible === false 的规则
  - all-warn: 所有规则都设为warn级别 all所有规则都设为error级别
  - incompatible-warn: incompatible规则都设为warn级别，不兼容的规则等价于没启用 incompatible所有规则都设为error级别

  5. main指向哪里 + 为什么动态生成configs
  - main指向index.js入口文件
  - 动态生成configs是为了
    a. 避免手写重复配置。规则数量多，如果每一条规则都手写配置，会难以维护。所以`configure(rule, level)`使用reduce批量配置规则级别。
    b. 保证规则名一致。有些规则名是驼峰，但是eslint rule key常用短横线分隔，所以使用`kabab-case`统一转换。
    c. 同一份规则数据驱动多套configs (all vs compatible)。入口将规则按compatible属性分类，组合成四套configs，后期只要rules.json改变，四套configs就会自动更新。
## 2）精读入口 index.js
- 练习：把 configure 改写成你能完全解释的版本（重点：reduce 如何累计对象）

configure最终返回一个对象，key是规则名，value是级别
这里假设list = ["concat", "dropRight"]
```js
configure(["concat", "dropRight"], 1)

// return
{
  'you-dont-need-lodash-underscore/concat': 1,
  'you-dont-need-lodash-underscore/drop-right': 1,
}
```
## 3）精读规则生成 lib/rules/all.js 的整体结构
- 重点：为什么要“for (const rule in rules)”批量导出

规则生成文件结构分析：
- 声明严格模式，导入处理规则名称需要的 kebab-case，导入规则元数据（`require('./rules')`，实际解析到同目录的 rules.json）
- 声明forbiddenLibs
- 创建getAssignmentLeftHandSide，如果声明表达式，那么返回声明表达式的id；如果赋值表达式，那么返回赋值表达式的left
- for循环遍历每一个规则，
  a. 从rules.json中获取规则的alternative（替代方案）和ruleName（规则名）
  b. 规则名生成与 alternative 无关：`ruleName = rules[rule].ruleName || kebabCase(rule)`（优先用显式 ruleName，否则把 rule 转成 kebab-case）
  c. forbiddenImports 不是从 forbiddenLibs “获取”的，而是按当前 rule 动态构造出来的一组“禁止导入路径映射”（如 `lodash/${rule}`、`lodash-es/${rule}`、`lodash.${rule.toLowerCase()}` 等）
  d. 导出规则，key是规则名，value是规则实现（create(context)返回visitor）
  模块导出的处理：
  - visitor 包含两个入口：CallExpression + ImportDeclaration
  - CallExpression 分三类命中（这里只负责 report message，不涉及规则 level，level 是在 index.js 的 configs 里配置的）：
    1) `require('lodash'|'lodash/fp'|'lodash-es')` 且父节点是“解构赋值/声明”：
       - 通过 parent（VariableDeclarator / AssignmentExpression）取到左侧（getAssignmentLeftHandSide）
       - 左侧是 ObjectPattern 时，遍历 properties，若 `property.key.name === rule` 则 report（对应 `const { indexOf } = require('lodash')` / `({ indexOf } = require('lodash'))`）
    2) `require('lodash/<rule>')` / `require('lodash-es/<rule>')` / `require('lodash.<rule>')` 等路径：当 requiredModuleName 命中 forbiddenImports 的 key 时直接 report
    3) `_.<rule>(...)` / `lodash.<rule>(...)` / `underscore.<rule>(...)` 以及 `_(...).<rule>(...)`：当 objectName 属于 `_ | lodash | underscore` 且 `callee.property.name === rule` 时 report
  - ImportDeclaration 分两类命中：
    1) `import { <rule> } from 'lodash'|'lodash/fp'|'lodash-es'`：遍历 specifiers，仅当 ImportSpecifier 且 imported.name === rule 时 report
    2) `import x from 'lodash/<rule>'` / `import x from 'lodash.<rule>'` 等：当 node.source.value 命中 forbiddenImports 的 key 时直接 report
## 4）只盯 CallExpression 分支：识别 _.xxx() / lodash.xxx() / underscore.xxx()
- 练习：手写 6 段会/不会触发的代码样例（先预测，再用源码条件逐条对照验证）

这里假设当前正在讨论的规则是 `dropRight`（即 rule === 'dropRight'）：

### 会触发（3 段）

1）直接调用 `_` / `lodash` / `underscore` 的方法

```js
_.dropRight([1, 2, 3], 1);
```

命中原因：objectName === '_' 且 callee.property.name === 'dropRight'

2）通过 `lodash` 名称调用

```js
lodash.dropRight([1, 2, 3], 1);
```

命中原因：objectName === 'lodash' 且 callee.property.name === 'dropRight'

3）链式调用（`_(...).dropRight()`）

```js
_( [1, 2, 3] ).dropRight(1);
```

命中原因：objectName 会取到 `callee.object.callee.name === '_'`，且 callee.property.name === 'dropRight'

### 不会触发（3 段）

4）方法名不匹配（只匹配 callee.property.name === rule）

```js
_.drop([1, 2, 3], 1);
```

不命中原因：callee.property.name === 'drop'，不等于 'dropRight'

5）对象名不匹配（只匹配 `_ | lodash | underscore`）

```js
myUtils.dropRight([1, 2, 3], 1);
```

不命中原因：objectName === 'myUtils'，不在 `_ | lodash | underscore`

6）不是调用表达式（CallExpression 只抓“被调用”的节点）

```js
const fn = _.dropRight;
```

不命中原因：这是取属性，不是函数调用，不会进入 CallExpression visitor
## 5）只盯 require 分支：识别 require('lodash/xxx') 与 const { xxx } = require('lodash')
- 重点：ObjectPattern、VariableDeclarator vs AssignmentExpression（getAssignmentLeftHandSide）

### require 分支的命中逻辑

1） 触发前置条件（最重要）

- 这个分支只处理什么 AST 节点？
当前分支只处理 CallExpression（函数调用表达式）节点。require 是函数调用，所以只要命中 require(...) 形式就会进入该分支；随后根据 parent 判断是否属于“解构 require('lodash')”的场景（VariableDeclarator / AssignmentExpression）
- 必须满足哪些“入口条件”？（提示：objectName + arguments.length）
objectName === 'require' && arguments.length === 1

2） 分支 A：require('lodash'|'lodash/fp'|'lodash-es') + 解构

- 发生在哪种父节点上？
- parent 是 VariableDeclarator 或 AssignmentExpression，且左侧是 ObjectPattern（对象解构），例如：
  - const { dropRight } = require('lodash')
  - ({ dropRight } = require('lodash'))
- 为什么要 getAssignmentLeftHandSide ？
为了统一获取“左侧表达式”：VariableDeclarator 用 node.id，AssignmentExpression 用 node.left
- 什么情况下会 report？
当 requiredModuleName ∈ forbiddenLibs（'lodash' | 'lodash/fp' | 'lodash-es'），且 ObjectPattern 中存在 property.key.name === rule 时 report
3） 分支 B：require('lodash/ <rule>') 或 lodash.</rule>

- 命中的核心判定是什么？
- requiredModuleName 命中 forbiddenImports 的 key（例如 lodash/<rule>、lodash-es/<rule>、lodash.<rule.toLowerCase()>）
- forbiddenImports 是怎么构造的？
- 由当前 rule 动态拼出多种可能的导入路径并放到对象 key 中，用 hasOwnProperty 进行 O(1) 判断
- 这一支为什么不用看 parent？
因为这里关心的是“直接 require 某个模块路径”，不依赖赋值/解构形态
4） 示例 4 组（2 触发 + 2 不触发）

- 每个示例写出“命中/不命中原因”
- 必须覆盖：
  - const { dropRight } = require('lodash')
  - require('lodash/dropRight')
  - const { dropRight } = require('lodash-es')
  - const { drop } = require('lodash')（在 dropRight 规则下不命中）

```js
// 这里假设当前正在讨论的规则是 dropRight（rule === 'dropRight'）

// 触发：分支 A（基库 + 解构）
const { dropRight } = require('lodash');
// 命中原因：requiredModuleName === 'lodash' ∈ forbiddenLibs，且 parent 左侧是 ObjectPattern，
// 并且 ObjectPattern 中存在 property.key.name === 'dropRight'

// 触发：分支 B（直接 require 某个方法模块）
require('lodash/dropRight');
// 命中原因：requiredModuleName === 'lodash/dropRight' 命中 forbiddenImports 的 key

// 触发：分支 A（基库 + 解构，换成 lodash-es）
const { dropRight: dr } = require('lodash-es');
// 命中原因：requiredModuleName === 'lodash-es' ∈ forbiddenLibs
// 注意：即使把 dropRight 重命名为 dr，property.key.name 仍然是 dropRight，所以仍命中

// 不触发：分支 A（解构字段不匹配当前规则名）
const { drop } = require('lodash');
// 不命中原因：虽然 requiredModuleName === 'lodash' ∈ forbiddenLibs 且是 ObjectPattern，
// 但解构字段是 drop，property.key.name !== 'dropRight'
```

## 6）import 分支怎么命中

这里假设当前讨论的规则是 `isNaN`（即 rule === 'isNaN'），并且 alternative 是 `Number.isNaN()`（参考 tests 中的用例）。

ImportDeclaration 分两类命中：

1）从基库导入（source 是 forbiddenLibs 之一：lodash / lodash/fp / lodash-es / lodash-es/fp）

```js
import { isNaN } from 'lodash';
import { isNaN as x } from 'lodash-es';
```

- 命中原因：node.source.value ∈ forbiddenLibs，且 specifier 是 ImportSpecifier，并且 specifier.imported.name === rule

2）从方法路径导入（source 命中 forbiddenImports 的 key）

```js
import isNaN from 'lodash/isNaN';
import isNaN from 'lodash.isnan';
import isNaN from 'lodash-es/isNaN';
```

- 命中原因：node.source.value 命中 forbiddenImports 的 key（无需检查 specifiers）

不命中例子：

```js
import isNaN from 'lodash';
```

- 不命中原因：从 'lodash' 导入默认导出时，specifier.type 是 ImportDefaultSpecifier，不会走 ImportSpecifier 的判断

## 7）rules.json 字段含义（数据驱动的核心）

rules.json 的每个 key（例如 dropRight / isNaN / trim）就是一条“方法规则”的源数据，all.js 会基于它生成对应的 ESLint rule。

常见字段：

- compatible：是否“原生替代与 lodash/underscore 的行为足够一致”
  - true：在 compatible 配置里会作为 error
  - false：在 compatible 配置里会作为 warn（提醒你注意兼容性/行为差异）
- alternative：提示信息里展示的“原生替代方案”（最终会拼进 `Consider using the native ${alternative}`）
- ruleName：可选。用于覆盖默认的 kebab-case 命名（例如把 isNaN 显式命名成 is-nan）
- ES6 / ES13：标注该替代方案出现的 ECMAScript 版本信息（当前实现主要用于文档/认知，规则逻辑本身不依赖它）

练习（已在代码里完成一次）：

- 新增了一条规则 trimEnd，只改 rules.json：
  - key：trimEnd
  - compatible：false（lodash 的 trimEnd 支持自定义字符集，原生 trimEnd 只处理空白字符，行为不完全一致）
  - alternative：String.prototype.trimEnd()

你现在应该能推导出：

- 规则名会被生成 kebab-case（例如 trimEnd 会变成 trim-end）
- 配置里对应的规则 key：you-dont-need-lodash-underscore/trim-end
- 会提示的 message 会包含：String.prototype.trimEnd()

## 8）RuleTester 的最小模板（用来验证一条规则）

tests/lib/rules/all.js 里使用 eslint.RuleTester 做冒烟测试。你读它的目标是：能写出一条规则的最小 valid/invalid。

最小模板（结构）：

```js
const RuleTester = require('eslint').RuleTester;
const rules = require('../../../lib/rules/all');

const ruleTester = new RuleTester({
  parserOptions: { ecmaVersion: 2018, sourceType: 'module' }
});

ruleTester.run('<case name>', rules['<rule-name>'], {
  valid: [
    '<不会触发的代码>'
  ],
  invalid: [{
    code: '<会触发的代码>',
    errors: ['<精确匹配 message>']
  }]
});
```

阅读时你重点关注三件事：

- rules['<rule-name>'] 的 key 为什么有些是 kebab-case（对应 rules.json 的 ruleName 或 kebabCase 结果）
- invalid.errors 为什么要写精确 message（因为规则只 report message，不带 node type/loc 自定义）
- parserOptions 为什么要开 module（否则 import 语句解析不了）

## 9）单元示例里的“原生替代不一定 1:1”的典型差异

读 tests/unit/all.js 的目的不是背代码，而是总结“替代时要警惕的差异类型”：

- null-safe 差异：lodash 常常对 null/undefined 更宽容，原生方法会直接抛错或行为不同
- 可变性差异：有些原生方法会修改原数组（例如 reverse），lodash 往往返回新数组或有不同习惯用法
- 参数语义差异：lodash API 可能支持更多参数/更丰富行为，原生替代通常更简单
- 对象 vs 数组差异：lodash 的 collection 方法常同时支持 object/array，原生替代多是数组方法（对象要 Object.entries/keys 辅助）

## 10）综合实战（用 trimEnd 串一次“数据→规则→配置→触发点”）

这一步你要把新增的一条规则，从“写进 JSON”推进到“你能完整解释它如何工作”：

1）数据：rules.json 新增 trimEnd（compatible=false, alternative=String.prototype.trimEnd()）
2）规则名：all.js 里 ruleName = kebabCase('trimEnd') => 'trim-end'
3）触发点：
   - _.trimEnd(str)
   - lodash.trimEnd(str)
   - require('lodash/trimEnd')
   - import { trimEnd } from 'lodash'
4）配置结果：
   - all：trim-end 会是 error
   - compatible：trim-end 会是 warn（因为 compatible=false）

你写完这一节后，你应该能回答：为什么“只改 JSON”就能让 ESLint 插件多一条规则。
